# Copyright (c) 2013 Shotgun Software Inc.
#
# CONFIDENTIAL AND PROPRIETARY
#
# This work is provided "AS IS" and subject to the Shotgun Pipeline Toolkit
# Source Code License included in this distribution package. See LICENSE.
# By accessing, using, copying or modifying this work you indicate your
# agreement to the Shotgun Pipeline Toolkit Source Code License. All rights
# not expressly granted therein are reserved by Shotgun Software Inc.

from tank import Hook
import maya.cmds as cmds
import pymel.core as pm
import os

class BreakdownSceneOperations(Hook):
    """
    Breakdown operations for Maya.

    This implementation handles detection of maya references and file texture nodes.
    """

    def scan_scene(self):
        """
        The scan scene method is executed once at startup and its purpose is
        to analyze the current scene and return a list of references that are
        to be potentially operated on.

        The return data structure is a list of dictionaries. Each scene reference
        that is returned should be represented by a dictionary with three keys:

        - "node": The name of the 'node' that is to be operated on. Most DCCs have
          a concept of a node, path or some other way to address a particular
          object in the scene.
        - "type": The object type that this is. This is later passed to the
          update method so that it knows how to handle the object.
        - "path": Path on disk to the referenced object.

        Toolkit will scan the list of items, see if any of the objects matches
        any templates and try to determine if there is a more recent version
        available. Any such versions are then displayed in the UI as out of date.
        """

        refs = []

        # first let's look at maya references
        for x in pm.listReferences():
            node_name = x.refNode.longName()

            # get the path and make it platform dependent
            # (maya uses C:/style/paths)
            maya_path = x.path.replace("/", os.path.sep)
            refs.append( {"node": node_name, "type": "reference", "path": maya_path})

        # now look at file texture nodes
        for file_node in cmds.ls(l=True, type="file"):
            # ensure this is actually part of this scene and not referenced
            if cmds.referenceQuery(file_node, isNodeReferenced=True):
                # this is embedded in another reference, so don't include it in the breakdown
                continue

            # get path and make it platform dependent (maya uses C:/style/paths)
            path = cmds.getAttr("%s.fileTextureName" % file_node).replace("/", os.path.sep)

            refs.append( {"node": file_node, "type": "file", "path": path})

        # now look for maya geo cache nodes
        for cache_node in cmds.ls(l=True, type="cacheFile"):
            # get path and make it platform dependent (maya uses C:/style/paths)
            path = cmds.getAttr("%s.cachePath" % cache_node).replace("/", os.path.sep)
            # strip off the asset specific extension to get down to just the version
            path = os.path.dirname(path)

            refs.append( {"node": cache_node, "type": "cacheFile", "path": path})

        # Alembic cache nodes!
        alembic_nodes = {}
        # Ensure later nodes overwrite the old ones
        alembic_file_nodes = cmds.ls(l=True, type="ExocortexAlembicFile")
        alembic_file_nodes.sort(key=(lambda node: int(filter(str.isdigit, str(node)))))
        for alembic_node in alembic_file_nodes:
            path = cmds.getAttr("%s.fileName" % alembic_node).replace("/", os.path.sep)
            # Ignore old AlembicFile nodes
            alembic_nodes[os.path.basename(path)] = {"node": alembic_node, "type": "alembic", "path": path}

        for ref in alembic_nodes.itervalues():
            refs.append(ref)

        print "REFFFSSS", refs
        return refs


    def update(self, items):
        """
        Perform replacements given a number of scene items passed from the app.

        Once a selection has been performed in the main UI and the user clicks
        the update button, this method is called.

        The items parameter is a list of dictionaries on the same form as was
        generated by the scan_scene hook above. The path key now holds
        the that each node should be updated *to* rather than the current path.
        """

        engine = self.parent.engine

        for i in items:

            node = i["node"]
            node_type = i["type"]
            new_path = i["path"]

            if node_type == "reference":
                # maya reference
                engine.log_debug("Maya Reference %s: Updating to version %s" % (node, new_path))
                rn = pm.system.FileReference(node)
                rn.replaceWith(new_path)

            elif node_type == "file":
                # file texture node
                engine.log_debug("File Texture %s: Updating to version %s" % (node, new_path))
                file_name = cmds.getAttr("%s.fileTextureName" % node)
                cmds.setAttr("%s.fileTextureName" % node, new_path, type="string")

            elif node_type == "cacheFile":
                # maya geocache node
                new_path = new_path.replace('\\','/')
                engine.log_debug("GeoCache %s: Updating to version %s" % (node, new_path))
                cachePath = cmds.getAttr("%s.cachePath" % node)
                # append the asset name (taken from current path) to the new path
                new_path = new_path + cachePath[len(new_path):]
                cmds.setAttr("%s.cachePath" %node, new_path, type="string")
            elif node_type == "alembic":
                try:
                    cmds.ExocortexAlembic_import(j="filename=" + new_path + ";normals=0;uvs=0;facesets=0;attachToExisting=1;overXforms=0;overDeforms=0;")
                except RuntimeError:
                    import traceback
                    pm.warning(traceback.format_exc())
